## 1. 查找表的定义与相关术语

分类成静态查找表和动态查找表。

![image-20201014093516768](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014093516768.png)

![image-20201014093611497](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014093611497.png)

## 2. 静态查找表

### 1. 顺序表

![image-20201014093721712](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014093721712.png)

```c++
size_t seq_search(vector<int> &dict, int key)
{
    /* 设置哨兵，减少循环内的比较次数 */
    dict[0] = key;
    size_t i;
    for(i = dict.size()-1; dict.at(i) != key;i--);
    return i;
}
```

![image-20201014093823985](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014093823985.png)

#### 查找性能分析

![image-20201014093913866](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014093913866.png)

![image-20201014093921350](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014093921350.png)

### 2. 有序表的查找

有序表的查找采用二分查找的方法。算法如下：

```c++
int my_binary_search(const vector<int> &dict,int key)
{
    int low  = 0, high = dict.size()-1;
    int mid;
    
    while(low < high){
        mid = (low+high)/2;
        if(key < dict[mid]){
            high = mid-1;
        }else if(key > dict[mid]){
            low = mid+1;
        }else{
            return mid;
        }
    }
    
    return -1;
}

```

![image-20201014094213172](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014094213172.png)

#### 查找性能分析

![image-20201014094307302](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014094307302.png)

### 3. 静态最优查找树

![image-20201014094410867](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014094410867.png)

#### 1. 次优查找树

最优查找树是使得带权内路径长度PH值所有具有同样权值的二叉树中近似为最小，这类二叉树为次优查找树。注意和哈夫曼树的区别，两者都是使得带权路径长度和最短，但是哈夫曼树没有查找树的特性（左子树小于右子树）。

![image-20201014095921583](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014095921583.png)

#### 代码

```c++

struct key_node{
    string key;
    int weight;

    key_node(): key(),weight(-1) {}
};

class second_optimal_search_tree{
private:
    struct node{
        struct key_node knode;
        struct node *lchild, *rchild;

        node() {
           lchild = rchild = nullptr;
        }
    };
public:
    second_optimal_search_tree()=default;

    bool create_search_tree(vector<key_node> &knodes){
        /* sort first */
        sort(knodes.begin(),knodes.end(),[](struct key_node &node1, struct key_node &node2){
            return node1.key.compare(node2.key) < 0;
        });

        /* 求累计权重和 */
        vector<int> sw(knodes.size(),0);
        sw[0] = knodes[0].weight;
        for(int i = 1;i<sw.size();i++){
            sw[i] = sw[i-1] + knodes[i].weight;
        }

        /* build tree */
        _create_tree(knodes,sw,0,knodes.size()-1,root);

        return true;
    }

    void print_tree(){
        _print_tree(root);
    }

    // if failed, return null
    const struct key_node *search(string key) const{
        struct node *cur = root;
        while(cur != nullptr && cur->knode.key != "#"){
            if(cur->knode.key.compare(key) < 0){
                cur = cur->rchild;
            }else if(cur->knode.key.compare(key) > 0){
                cur = cur->lchild;
            }else{
                return &cur->knode;
            }
        }
        return nullptr;
    }
private:

    void _print_tree(struct node *t){
        if(t == nullptr) return;
        cout << t->knode.key << " " << t->knode.weight << "\n";
        _print_tree(t->lchild);
        _print_tree(t->rchild);
    }

    void _create_tree(const vector<key_node> &knodes, const vector<int> &sw, int low, int high, struct node *&t){
        t = new node;
        if(low > high){
            return ;
        }
        else if(low == high){      /* 叶节点 */
            t->knode.key = knodes[low].key;
            t->knode.weight = knodes[low].weight;
            t->lchild = t->rchild = new node;       /* 下面3行不用写，这里是为了打印tree时更好的推断树的形状所以添加的 */
            t->lchild->knode.key = "#";
            t->rchild->knode.weight = -1;
        }
        else       /* 中间节点 */
        {
            int min_idx = low;
            int min_delta = abs(sw[high] - sw[low+1]);  /* 用low作root */
            /* 确定最小idx */
            for(int i = low+1;i<=high;i++){
                int rw = sw[high] - sw[i];
                int lw = sw[i-1] - sw[low] + knodes[low].weight;
                if(min_delta > abs(rw-lw)){
                    min_idx = i;
                    min_delta = rw - lw;
                }
            }

            t->knode.weight = knodes[min_idx].weight;
            t->knode.key = knodes[min_idx].key;
            /* 构造左子树和右子树 */
            _create_tree(knodes,sw,low,min_idx-1,t->lchild);
            _create_tree(knodes,sw,min_idx+1,high,t->rchild);
        }
    }


private:
    struct node *root;
};
```

### 4. 索引表顺序查找

![image-20201014100220576](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014100220576.png)

## 3. 动态查找表

### 1. 定义

![image-20201014100252181](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014100252181.png)

### 2. 二叉排序树

#### 1. 定义

![image-20201014100324936](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014100324936.png)

二叉查找树的操作包括： Insert， Delete和Search。其中Delete操作较难。分为3种情况讨论。

这部分代码建议

#### 2. 代码

```c++
// C++ program to demonstrate delete operation in binary search tree 
#include<bits/stdc++.h> 
using namespace std; 

struct node 
{ 
	int key; 
	struct node *left, *right; 
}; 

// A utility function to create a new BST node 
struct node *newNode(int item) 
{ 
	struct node *temp = (struct node *)malloc(sizeof(struct node)); 
	temp->key = item; 
	temp->left = temp->right = NULL; 
	return temp; 
} 

// A utility function to do inorder traversal of BST 
void inorder(struct node *root) 
{ 
	if (root != NULL) 
	{ 
		inorder(root->left); 
		cout<< root->key; 
		inorder(root->right); 
	} 
} 

/* A utility function to insert a new node with given key in BST */
struct node* insert(struct node* node, int key) 
{ 
	/* If the tree is empty, return a new node */
	if (node == NULL) return newNode(key); 

	/* Otherwise, recur down the tree */
	if (key < node->key) 
		node->left = insert(node->left, key); 
	else
		node->right = insert(node->right, key); 

	/* return the (unchanged) node pointer */
	return node; 
} 

/* Given a non-empty binary search tree, return the node with minimum 
key value found in that tree. Note that the entire tree does not 
need to be searched. */
struct node * minValueNode(struct node* node) 
{ 
	struct node* current = node; 

	/* loop down to find the leftmost leaf */
	while (current && current->left != NULL) 
		current = current->left; 

	return current; 
} 

/* Given a binary search tree and a key, this function deletes the key 
and returns the new root */
struct node* deleteNode(struct node* root, int key) 
{ 
	// base case 
	if (root == NULL) return root; 

	// If the key to be deleted is smaller than the root's key, 
	// then it lies in left subtree 
	if (key < root->key) 
		root->left = deleteNode(root->left, key); 

	// If the key to be deleted is greater than the root's key, 
	// then it lies in right subtree 
	else if (key > root->key) 
		root->right = deleteNode(root->right, key); 

	// if key is same as root's key, then This is the node 
	// to be deleted 
	else
	{ 
		// node with only one child or no child 
		if (root->left == NULL) 
		{ 
			struct node *temp = root->right; 
			free(root); 
			return temp; 
		} 
		else if (root->right == NULL) 
		{ 
			struct node *temp = root->left; 
			free(root); 
			return temp; 
		} 

		// node with two children: Get the inorder successor (smallest 
		// in the right subtree) 
		struct node* temp = minValueNode(root->right); 

		// Copy the inorder successor's content to this node 
		root->key = temp->key; 

		// Delete the inorder successor 
		root->right = deleteNode(root->right, temp->key); 
	} 
	return root; 
} 

// Driver Program to test above functions 
int main() 
{ 
	/* Let us create following BST 
			50 
		/	 \ 
		30	 70 
		/ \ / \ 
	20 40 60 80 */
	struct node *root = NULL; 
	root = insert(root, 50); 
	root = insert(root, 30); 
	root = insert(root, 20); 
	root = insert(root, 40); 
	root = insert(root, 70); 
	root = insert(root, 60); 
	root = insert(root, 80); 

	cout << "Inorder traversal of the given tree \n"; 
	inorder(root); 

	cout<<"\nDelete 20\n"; 
	root = deleteNode(root, 20); 
	cout<<"Inorder traversal of the modified tree \n"; 
	inorder(root); 

	cout<<"\nDelete 30\n"; 
	root = deleteNode(root, 30); 
	cout<<"Inorder traversal of the modified tree \n"; 
	inorder(root); 

	cout<<"\nDelete 50\n"; 
	root = deleteNode(root, 50); 
	cout<<"Inorder traversal of the modified tree \n"; 
	inorder(root); 

	return 0; 
} 

// This code is contributed by shivanisinghss2110 

```

#### 3. 查找性能分析

![image-20201014100805891](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014100805891.png)

![image-20201014100856759](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014100856759.png)

#### 4. 时间复杂度

- 平均性能 O(logn)

- 最差性能 O(n)

### 3. AVL树

这部分建议直接看 https://www.geeksforgeeks.org/avl-tree-set-1-insertion/

AVL树通过旋转操作解决了BST的不平衡的因素。

#### 1. 定义

![image-20201014101025315](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014101025315.png)

#### 2. 插入操作

参考图：

<img src="https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014101250224.png" alt="image-20201014101250224" style="zoom: 50%;" />

![image-20201014101309821](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014101309821.png)

#### 3. 插入操作代码

先按照BST正常插入，然后递归向上地平衡。

```c++
    // 插入key节点，返回插入修改后的root节点
    struct node *_insert(struct node *t, int key)
    {
        if (t == nullptr) {
            return new node(key);
        } else {
            /* 正常bst递归插入 */
            if (key < t->key) {
                t->lchild = _insert(t->lchild, key);
            } else if (key > t->key) {
                t->rchild = _insert(t->rchild, key);
            } else {
                return t;       /* 忽略已经有的key */
            }
            
            /* 插入后，更新当前节点的height */
            t->height = 1 + max(height(t->lchild), height(t->rchild));
            
            /* 获取平衡因子，查看是否需要旋转来保持avl特性 */
            int balance = get_balance(t);
            
            /* 根据balance来rotate */
            if (balance > 1 && key < t->lchild->key) {    /* 左左-- 单右旋即可 */
                return right_rotate(t);
            } else if (balance > 1 && key > t->lchild->key) {      /* 左右 -- 先左后右  */
                t->lchild = left_rotate(t->lchild);
                return right_rotate(t);
            } else if (balance < -1 && key > t->rchild->key) {  /* 右右--单左旋 */
                return left_rotate(t);
            } else if (balance < -1 && key < t->rchild->key) {  /* 右左--先右后左 */
                t->rchild = right_rotate(t->rchild);
                return left_rotate(t);
            }
            return t;
        }
    }
```

#### 4. 删除操作

删除操作和插入操作同理，先按照BST的删除。然后递归向上平衡。 但是和insert不同，删除可能在中间节点删除，这部分的处理直接看代码：

```c++
   // 删除key所在节点，返回修改后的子树root节点
    struct node *_remove(struct node *t, int key)
    {
        if (t == nullptr) return t;
        else {
            /* 执行bst的删除 */
            if (key < t->key) {
                t->lchild = _remove(t->lchild, key);
            } else if (key > t->key) {
                t->rchild = _remove(t->rchild, key);
            } else       /* key相等，需要删除 */
            {
                if (t->rchild == nullptr || t->lchild == nullptr) {   /* 叶子节点，或者单孩子节点 */
                    struct node *temp = t->lchild != nullptr ? t->lchild : t->rchild;
                    if (temp == nullptr) {    /* 叶子节点 */
                        temp = t;
                        t = nullptr;
                    } else {              /* 单孩子节点 */
                        t->key = temp->key;
                        if(t->lchild == temp) t->lchild = nullptr;
                        else t->rchild = nullptr;
                    }
                    free(temp);
                    return t;
                } else        /* 中间节点 */
                {
                    struct node *succ = in_order_successor(t);
                    t->key = succ->key;
                    t->rchild = _remove(t->rchild, succ->key);		// ！！！中间节点，继续往下追踪
                }
            }
            
            /* 更新height */
            t->height = 1 + max(height(t->lchild), height(t->rchild));
            
            /* 获取balance */
            int balance = get_balance(t);
            
            /* re-balance */
            /* 根据balance来rotate */
            /* get_balance(t->lchild) = 0 时，代表单右旋或先左后右均可 */
            if (balance > 1 && get_balance(t->lchild) >= 0) {        /* 左左-- 单右旋 */
                return right_rotate(t);
            } else if (balance > 1 && get_balance(t->lchild) < 0) {      /* 左右 -- 先左后右  */
                t->lchild = left_rotate(t->lchild);
                return right_rotate(t);
            } else if (balance < -1 && get_balance(t->rchild) <= 0) {  /* 右右--单左旋 */
                return left_rotate(t);
            } else if (balance < -1 && get_balance(t->rchild) > 0) {  /* 右左--先右后左 */
                t->rchild = right_rotate(t->rchild);
                return left_rotate(t);
            }
        }
        return t;
    }
```

#### 5. 全代码

```c++
/**
 * Created by a2855 on 2020/9/28.
 */
#include <iostream>
#include <vector>

using namespace std;

class avl_tree {
private:
    struct node {
        int key;
        struct node *lchild;
        struct node *rchild;
        int height;         /* 子树高度 */
        
        explicit node(int key) : key(key)
        {
            lchild = rchild = nullptr;
            height = 1;
        }
    };

private:
    void _post_order_print(struct node *t)
    {
        if (t == nullptr) return;
        _post_order_print(t->lchild);
        cout << t->key << " ";
        _post_order_print(t->rchild);
    }
    
    int height(struct node *t) const
    {
        return t == nullptr ? 0 : t->height;
    }
    
    // get balance factor of node t, assume 1 indicating the height of
    // left child tree is larger than the right, -1 vice versa.
    int get_balance(struct node *t) const
    {
        return height(t->lchild) - height(t->rchild);
    }
    
    // 以node t作为根右旋，返回右旋后的根节点
    struct node *right_rotate(struct node *t)
    {
        struct node *lc = t->lchild;
        t->lchild = lc->rchild;
        lc->rchild = t;
        
        t->height = 1 + max(height(t->lchild), height(t->rchild));
        lc->height = 1 + max(height(lc->lchild), height(lc->rchild));
        return lc;
    }
    
    // 以node t作为根左旋，返回左旋后的根节点
    struct node *left_rotate(struct node *t)
    {
        struct node *rc = t->rchild;
        t->rchild = rc->lchild;
        rc->lchild = t;
        
        t->height = 1 + max(height(t->lchild), height(t->rchild));
        rc->height = 1 + max(height(rc->lchild), height(rc->rchild));
        return rc;
    }
    
    // 插入key节点，返回插入修改后的root节点
    struct node *_insert(struct node *t, int key)
    {
        if (t == nullptr) {
            return new node(key);
        } else {
            /* 正常bst递归插入 */
            if (key < t->key) {
                t->lchild = _insert(t->lchild, key);
            } else if (key > t->key) {
                t->rchild = _insert(t->rchild, key);
            } else {
                return t;       /* 忽略已经有的key */
            }
            
            /* 插入后，更新当前节点的height */
            t->height = 1 + max(height(t->lchild), height(t->rchild));
            
            /* 获取平衡因子，查看是否需要旋转来保持avl特性 */
            int balance = get_balance(t);
            
            /* 根据balance来rotate */
            if (balance > 1 && key < t->lchild->key) {    /* 左左-- 单右旋即可 */
                return right_rotate(t);
            } else if (balance > 1 && key > t->lchild->key) {      /* 左右 -- 先左后右  */
                t->lchild = left_rotate(t->lchild);
                return right_rotate(t);
            } else if (balance < -1 && key > t->rchild->key) {  /* 右右--单左旋 */
                return left_rotate(t);
            } else if (balance < -1 && key < t->rchild->key) {  /* 右左--先右后左 */
                t->rchild = right_rotate(t->rchild);
                return left_rotate(t);
            }
            return t;
        }
    }
    
    // 中序后继节点
    struct node *in_order_successor(struct node *t)
    {
        struct node *succ = t->rchild;
        while (succ->lchild != nullptr) {
            succ = succ->lchild;
        }
        return succ;
    }
    
    // 删除key所在节点，返回修改后的子树root节点
    struct node *_remove(struct node *t, int key)
    {
        if (t == nullptr) return t;
        else {
            /* 执行bst的删除 */
            if (key < t->key) {
                t->lchild = _remove(t->lchild, key);
            } else if (key > t->key) {
                t->rchild = _remove(t->rchild, key);
            } else       /* key相等，需要删除 */
            {
                if (t->rchild == nullptr || t->lchild == nullptr) {   /* 叶子节点，或者单孩子节点 */
                    struct node *temp = t->lchild != nullptr ? t->lchild : t->rchild;
                    if (temp == nullptr) {    /* 叶子节点 */
                        temp = t;
                        t = nullptr;
                    } else {              /* 单孩子节点 */
                        t->key = temp->key;
                        if(t->lchild == temp) t->lchild = nullptr;
                        else t->rchild = nullptr;
                    }
                    free(temp);
                    return t;
                } else        /* 中间节点 */
                {
                    struct node *succ = in_order_successor(t);
                    t->key = succ->key;
                    t->rchild = _remove(t->rchild, succ->key);
                }
            }
            
            /* 更新height */
            t->height = 1 + max(height(t->lchild), height(t->rchild));
            
            /* 获取balance */
            int balance = get_balance(t);
            
            /* re-balance */
            /* 根据balance来rotate */
            /* get_balance(t->lchild) = 0 时，代表单右旋或先左后右均可 */
            if (balance > 1 && get_balance(t->lchild) >= 0) {        /* 左左-- 单右旋 */
                return right_rotate(t);
            } else if (balance > 1 && get_balance(t->lchild) < 0) {      /* 左右 -- 先左后右  */
                t->lchild = left_rotate(t->lchild);
                return right_rotate(t);
            } else if (balance < -1 && get_balance(t->rchild) <= 0) {  /* 右右--单左旋 */
                return left_rotate(t);
            } else if (balance < -1 && get_balance(t->rchild) > 0) {  /* 右左--先右后左 */
                t->rchild = right_rotate(t->rchild);
                return left_rotate(t);
            }
        }
        return t;
    }

public:
    avl_tree() : root(nullptr) {}
    
    void insert(int key)
    {
        if (root != nullptr) {
            root = _insert(root, key);
        } else {
            root = new node(key);
        }
    }
    
    void remove(int key)
    {
        root = _remove(root, key);
    }
    
    void post_order_print()
    {
        _post_order_print(root);
        cout << endl;
    }

private:
    struct node *root;
};


int main()
{
    avl_tree tree;
//    vector<int> vec{10,20,5,6,6516,276};
    vector<int> vec{6, 9, 8, 412, 1, 41, 439, 10, 5, 20, 246, 276, -1, 7};
//    vector<int> vec{10,20,5,6,15,30,25};
    
    for (int i = 0; i < vec.size(); i++) {
        tree.insert(vec[i]);
    }
    tree.post_order_print();
    
    tree.remove(5);
    tree.post_order_print();
    
    tree.remove(10);
    tree.post_order_print();
    
    tree.remove(439);
    tree.post_order_print();
    
    return 0;
}
```

#### 6. 查找性能分析

![image-20201014102411763](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014102411763.png)

#### 7. 时间复杂度

- O(logn)

### 5. B树

B和B+树广泛运用在数据库、文件系统中。

B树可减少磁盘IO次数，一个fat tree. B-Tree node 的 size通常和disk block size保持一致。

#### 1. 时间复杂度

**Time Complexity of B-Tree:**

| SR. NO. | ALGORITHM | TIME COMPLEXITY |
| :-----: | :-------: | :-------------: |
|   1.    |  Search   |    O(log n)     |
|   2.    |  Insert   |    O(log n)     |
|   3.    |  Delete   |    O(log n)     |

#### 2. 性质

B树的性质：

1. All leaves are at the same level.
2. A B-Tree is defined by the term ***minimum degree* ‘t’.** The value of t depends upon disk block size.
3. Every node except root must contain at least t-1 keys. The root may contain minimum 1 key.
4. All nodes (including root) may contain at most 2t – 1 keys.
5. Number of children of a node is equal to the number of keys in it plus 1
6. All keys of a node are sorted in increasing order. The child between two keys k1 and k2 contains all keys in the range from k1 and k2.
7. B-Tree grows and shrinks from the root which is unlike Binary Search Tree. Binary Search Trees grow downward and also shrink from downward.
8. Like other balanced Binary Search Trees, time complexity to search, insert and delete is O(log n).

#### 3. 搜索操作

搜索类似于二叉搜索树中的搜索。让要搜索的key-value为k，我们从根结点开始递归地遍历。对于每个访问过的非叶节点，如果该节点具有键，则只需返回该节点。否则，我们将返回到适当的子节点(恰好位于第一个大键之前的子节点)。如果我们到达一个叶节点，在这个叶节点中找不到k，我们返回NULL。

代码：

```c++
    struct node *_search(struct node *nd, int key)
    {
        int idx = 0;
        
        while (key < nd->keys[idx]) idx++;
        if (key == nd->keys[idx]) {
            return nd;
        } else {
            if (nd->leaf) return nullptr;
            else return _search(nd->children[idx], key);
        }
    }
  
```

##### 查找性能分析

![image-20201014103003694](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014103003694.png)

![image-20201014103028332](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014103028332.png)

#### 4. 插入操作

before inserting a key to the node, we make sure that the node has extra space.
*How to make sure that a node has space available for a key before the key is inserted?* We use an operation called splitChild() that is used to split a child of a node. See the following diagram to understand split. In the following diagram, child y of x is being split into two nodes y and z. Note that the splitChild operation moves a key up and this is the reason B-Trees grow up, unlike BSTs which grow down.

![BTreeSplit](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/BTreeSplit-1024x321.jpg)‘

As discussed above, to insert a new key, we go down from root to leaf. Before traversing down to a node, we first check if the node is full. If the node is full, we split it to create space. Following is the complete algorithm.

**Insertion**
**1)** Initialize x as root.
**2)** While x is not leaf, do following
..**a)** Find the child of x that is going to be traversed next. Let the child be y.
..**b)** If y is not full, change x to point to y.
..**c)** If y is full, split it and change x to point to one of the two parts of y. If k is smaller than mid key in y, then set x as the first part of y. Else second part of y. When we split y, we move a key from y to its parent x.
**3)** The loop in step 2 stops when x is leaf. x must have space for 1 extra key as we have been splitting all nodes in advance. So simply insert k to x.

Note that the algorithm follows the Cormen book. It is actually a proactive insertion algorithm where before going down to a node, we split it if it is full. The advantage of splitting before is, we never traverse a node twice. If we don’t split a node before going down to it and split it only if a new key is inserted (reactive), we may end up traversing all nodes again from leaf to root. This happens in cases when all nodes on the path from the root to leaf are full. So when we come to the leaf node, we split it and move a key up. Moving a key up will cause a split in parent node (because the parent was already full). This cascading effect never happens in this proactive insertion algorithm. There is a disadvantage of this proactive insertion though, we may do unnecessary splits.

Let us understand the algorithm with an example tree of minimum degree ‘t’ as 3 and a sequence of integers 10, 20, 30, 40, 50, 60, 70, 80 and 90 in an initially empty B-Tree.

Initially root is NULL. Let us first insert 10.
[![Btree1](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/Btree1.png)](https://media.geeksforgeeks.org/wp-content/cdn-uploads/Btree1.png)

Let us now insert 20, 30, 40 and 50. They all will be inserted in root because the maximum number of keys a node can accommodate is 2*t – 1 which is 5.

[![BTree2Ins](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/BTree2Ins.png)](https://media.geeksforgeeks.org/wp-content/cdn-uploads/BTree2Ins.png)

Let us now insert 60. Since root node is full, it will first split into two, then 60 will be inserted into the appropriate child.
[![BTreeIns3](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/BTreeIns3.png)](https://media.geeksforgeeks.org/wp-content/cdn-uploads/BTreeIns3.png)

Let us now insert 70 and 80. These new keys will be inserted into the appropriate leaf without any split.
[![BTreeIns4](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/BTreeIns4.png)](https://media.geeksforgeeks.org/wp-content/cdn-uploads/BTreeIns4.png)

Let us now insert 90. This insertion will cause a split. The middle key will go up to the parent.
[![BTreeIns6](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/BTreeIns6.png)](https://media.geeksforgeeks.org/wp-content/cdn-uploads/BTreeIns6.png)

Following is C++ implementation of the above proactive algorithm.

#### 5. 插入操作代码

```c++

    void insert(int key)
    {
        if (root == nullptr) {
            root = new node(t, true);
            root->keys[0] = key;
            root->n++;
        } else {
            if (root->n == root->t * 2 - 1) {     /* root is full */
                node *new_root = new node(t, false);
                split(new_root, 0, root);
                /* 更新root指针到新root */
                root = new_root;
            }
            insert_non_full(root, key);
        }
    }
    
    
     // 插入key的辅助函数
    // note: 调用本函数时，nd不能满
    void insert_non_full(struct node *nd, int key)
    {
        int i = nd->n - 1;
        if (nd->leaf) {        /* 叶子节点，执行插入 */
            /* 移动后半部分keys */
            while (i >= 0 && key < nd->keys[i]) {
                nd->keys[i + 1] = nd->keys[i];
                i--;
            }
            assert(i >= -1);
            nd->keys[i + 1] = key;
            nd->n++;
        } else {
            while (i >= 0 && key < nd->keys[i]) {
                i--;
            }
            assert(i >= -1);
            node *may_full_child = nd->children[i + 1];
            if (may_full_child->n == may_full_child->t * 2 - 1) {  /* child is full */
                split(nd, i + 1, may_full_child);
                if (key > nd->keys[i + 1]) {
                    i++;
                }
            }
            insert_non_full(nd->children[i + 1], key);
        }
    }
    
    // 拆分 “fullchild”， 移动fullchild的中间元素到 "parent“ 的 "pidx"位置
    // Note: 需要"fullchild" key满时才能调用本函数
    void split(struct node *parent, int pidx, struct node *fullchild)
    {
        int t = fullchild->t;
        /* 准备拆分后的后半段 */
        /* 拆分后的后半段node */
        node *right_node = new node(fullchild->t, fullchild->leaf);
        /* 复制fullchild的后半段keys元素到 right_node中 */
        for (int i = 0; i < t - 1; i++) {
            right_node->keys[i] = fullchild->keys[i + t];
        }
        /* 复制fullchild的后半段children到right_node中 */
        for (int i = 0; i < t; i++) {
            right_node->children[i] = fullchild->children[i + t];
        }
        right_node->n = t - 1;
        
        /* 拆分后的前半段 */
        fullchild->n = t - 1;
        
        /* 将fullchild的中间节点移动到parent中 */
        /* parent节点空间预留-- keys搬动 */
        int i = 0;
        int mid_key = fullchild->keys[t - 1];
        while (i< parent->n && mid_key > parent->keys[i]) i++;
        for (int j = parent->n; j > i; j--) {
            parent->keys[j] = parent->keys[j - 1];
        }
        /* move */
        parent->keys[i] = mid_key;
        parent->n++;
        
        /* parent children搬动 */
        for (int j = parent->n + 1; j > i; j--) {
            parent->children[j] = parent->children[j - 1];
        }
        /* parent 链接 前半段和后半段 */
        parent->children[i] = fullchild;
        parent->children[i + 1] = right_node;
    }
    
```

#### 6. 删除操作

参考：https://www.cnblogs.com/nullzx/p/8729425.html

但是下面的代码实现和参考链接中的示意图有所不同。因为不会递归合并。下面的代码在搜索过程中就会通过borrow来填充节点，避免出现节点内key不足的情况。

#### 7. 删除代码 （全部代码）

```c++
/**
 * Created by a2855 on 2020/9/29.
 * B tree
 * 实现说明：
 * 1.使用最小度 t 来定义一个node的key数量range
 * 2.在insert操作中，从root往下遍历时，发现有节点key数量过多时，就执行split，避免多次 IO（常规split可能造成级联的split）
 * 3.在delete操作中，从root往下遍历时，发现有节点key数量过少时，立即填充，避免多次IO（常规delete可能造成级联的merge）
 */
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

struct node {
    vector<int> keys;       /* keys 数组 */
    vector<node *> children;        /* child 指针, 数量为keys的数量+1 */
    int t;                  /* 最小度定义法，用于维护节点的key number range */
    bool leaf;              /* 是否是孩子节点 */
    int n;                  /* 当前持有key的数量 */
    /* 实际上还应该包含一个value指针数组，不过要理解Btree，并不需要它 */
    
    node(int t, bool leaf) : t(t), leaf(leaf)
    {
        keys.resize(2 * t - 1, -1);
        children.resize(2 * t, nullptr);
        n = 0;
    }
};

class b_tree {
public:
    b_tree(int t) : t(t), root(nullptr)
    {
        assert(t >= 2);
    }
    
    void traverse()
    {
        _traverse(root);
    }
    
    struct node *search(int key)
    {
        return _search(root, key);
    }
    
    void insert(int key)
    {
        if (root == nullptr) {
            root = new node(t, true);
            root->keys[0] = key;
            root->n++;
        } else {
            if (root->n == root->t * 2 - 1) {     /* root is full */
                node *new_root = new node(t, false);
                split(new_root, 0, root);
                /* 更新root指针到新root */
                root = new_root;
            }
            insert_non_full(root, key);
        }
    }
    
    void remove(int key)
    {
        _remove(root, key);
    }

private:
    void _traverse(struct node *nd)
    {
        if (nd == nullptr) return;
        
        for (int i = 0; i < nd->n; i++) {
            if (!nd->leaf) {
                _traverse(nd->children[i]);
            }
            cout << nd->keys[i] << " ";
        }
        if (!nd->leaf) {   /* 最后的孩子节点 */
            _traverse(nd->children[nd->n]);
        }
    }
    
    struct node *_search(struct node *nd, int key)
    {
        int idx = 0;
        
        while (key < nd->keys[idx]) idx++;
        if (key == nd->keys[idx]) {
            return nd;
        } else {
            if (nd->leaf) return nullptr;
            else return _search(nd->children[idx], key);
        }
        
    }
    
    // 拆分 “fullchild”， 移动fullchild的中间元素到 "parent“ 的 "pidx"位置
    // Note: 需要"fullchild" key满时才能调用本函数
    void split(struct node *parent, int pidx, struct node *fullchild)
    {
        int t = fullchild->t;
        /* 准备拆分后的后半段 */
        /* 拆分后的后半段node */
        node *right_node = new node(fullchild->t, fullchild->leaf);
        /* 复制fullchild的后半段keys元素到 right_node中 */
        for (int i = 0; i < t - 1; i++) {
            right_node->keys[i] = fullchild->keys[i + t];
        }
        /* 复制fullchild的后半段children到right_node中 */
        for (int i = 0; i < t; i++) {
            right_node->children[i] = fullchild->children[i + t];
        }
        right_node->n = t - 1;
        
        /* 拆分后的前半段 */
        fullchild->n = t - 1;
        
        /* 将fullchild的中间节点移动到parent中 */
        /* parent节点空间预留-- keys搬动 */
        int i = 0;
        int mid_key = fullchild->keys[t - 1];
        while (i< parent->n && mid_key > parent->keys[i]) i++;
        for (int j = parent->n; j > i; j--) {
            parent->keys[j] = parent->keys[j - 1];
        }
        /* move */
        parent->keys[i] = mid_key;
        parent->n++;
        
        /* parent children搬动 */
        for (int j = parent->n + 1; j > i; j--) {
            parent->children[j] = parent->children[j - 1];
        }
        /* parent 链接 前半段和后半段 */
        parent->children[i] = fullchild;
        parent->children[i + 1] = right_node;
    }
    
    // 插入key的辅助函数
    // note: 调用本函数时，nd不能满
    void insert_non_full(struct node *nd, int key)
    {
        int i = nd->n - 1;
        if (nd->leaf) {        /* 叶子节点，执行插入 */
            /* 移动后半部分keys */
            while (i >= 0 && key < nd->keys[i]) {
                nd->keys[i + 1] = nd->keys[i];
                i--;
            }
            assert(i >= -1);
            nd->keys[i + 1] = key;
            nd->n++;
        } else {
            while (i >= 0 && key < nd->keys[i]) {
                i--;
            }
            assert(i >= -1);
            node *may_full_child = nd->children[i + 1];
            if (may_full_child->n == may_full_child->t * 2 - 1) {  /* child is full */
                split(nd, i + 1, may_full_child);
                if (key > nd->keys[i + 1]) {
                    i++;
                }
            }
            insert_non_full(nd->children[i + 1], key);
        }
    }
    
    
    // 在nd中找到第一个比key大或相等的key位置
    int find_key(struct node *nd, int key)
    {
        int i = 0;
        while (i < nd->n && key > nd->keys[i]) {
            i++;
        }
        return i;
    }
    
    void _remove(struct node *nd, int key)
    {
        int idx = find_key(nd, key);
        
        if (idx < nd->n && key == nd->keys[idx]) {        /* 匹配到key */
            if (nd->leaf) {
                remove_from_leaf(nd, idx);
            } else {
                remove_from_non_leaf(nd, idx);
            }
        } else {      /* key不在本节点中 */
            if (nd->leaf) {       /* 已经是叶节点，说明key不存在 */
                cerr << "key does not exit in this tree\n";
                return;
            } else {      /* 在子树中寻找 */
                bool last_child = idx == nd->n;
                
                if (nd->children[idx]->n < nd->children[idx]->t) {    /* 即将遍历的节点keys个数不足，现在进行填充 */
                    fill(nd, idx);       /* 注意填充可能更改当前nd的children数量 */
                }
                
                if (last_child && idx > nd->n) {      /* 说明最后一个节点已经和前一个节点合并，现在要在前一个节点中删除 */
                    _remove(nd->children[idx - 1], key);
                } else {  /* 正常情况 */
                    _remove(nd->children[idx], key);
                }
            }
        }
    }
    
    // nd为叶子节点，删除第idx个元素
    // Note: 调用本函数时， nd中的keys个数一定>= t
    void remove_from_leaf(struct node *nd, int idx)
    {
        for (int i = idx; i < nd->n - 1; i++) {
            nd->keys[i] = nd->keys[i + 1];
        }
        nd->n--;
    }
    
    // nd为非叶子节点，删除第idx个元素
    void remove_from_non_leaf(struct node *nd, int idx)
    {
        int key = nd->keys[idx];
        
        if (nd->children[idx]->n >= nd->children[idx]->t) {   /* 用前驱代替key */
            int pred = get_pred(nd, idx);
            nd->keys[idx] = pred;
            _remove(nd->children[idx], pred);
        } else if (nd->children[idx + 1]->n >= nd->children[idx + 1]->t) { /* 用后驱代替key */
            int succ = get_succ(nd, idx);
            nd->keys[idx] = succ;
            _remove(nd->children[idx], succ);
        } else {      /* 两个孩子都不够，选择合并 */
            merge(nd, idx);
            _remove(nd->children[idx], key);
        }
    }
    
    // 取得nd->keys[idx] 的前驱节点
    // Note：nd不能是叶子节点
    int get_pred(struct node *nd, int idx)
    {
        assert(!nd->leaf);
        struct node *cur = nd->children[idx];
        while (!cur->leaf) {
            cur = cur->children[cur->n];
        }
        return cur->keys[cur->n - 1];
    }
    
    
    // 取得nd->keys[idx]的后继节点
    // Note: nd不能是叶子节点
    int get_succ(struct node *nd, int idx)
    {
        assert(!nd->leaf);
        struct node *cur = nd->children[idx + 1];
        while (!cur->leaf) {
            cur = cur->children[0];
        }
        return cur->keys[0];
    }
    
    
    // 填充nd->children[idx]
    // Note: 调用此函数时，nd->children[idx]->n 应 <= t-1
    void fill(struct node *nd, int idx)
    {
        assert(nd->children[idx]->n <= nd->children[idx]->t - 1);
        if (idx != 0 && nd->children[idx - 1]->n >= t) { /* 向左兄弟节点借 */
            borrow_from_prev(nd, idx);
        } else if (idx != nd->n && nd->children[idx + 1]->n >= t) {      /* 向右兄弟借 */
            borrow_from_next(nd, idx);
        } else {      /* 两个兄弟都不够 */
            if (idx < nd->n) {
                merge(nd, idx);         /* 合并右兄弟 */
            } else {
                merge(nd, idx - 1);        /* 合并左兄弟 */
            }
        }
    }
    
    // 向nd->children[idx-1]借一个key，插入到nd->children[idx]中
    void borrow_from_prev(struct node *nd, int idx)
    {
        assert(idx > 0);
        struct node *child = nd->children[idx];
        struct node *sibling = nd->children[idx - 1];
        
        /* 移动"child"的所有keys，给从parent中的key留一个空间 */
        for (int i = child->n; i > 0; i--) {
            child->keys[i] = child->keys[i - 1];
        }
        /* 如果child不是叶子节点，则移动child的children指针 */
        if (!child->leaf) {
            for (int i = child->n + 1; i > 0; i--) {
                child->children[i] = child->children[i - 1];
            }
        }
        /* 插入从parent来的key */
        child->keys[0] = nd->keys[idx];
        
        /* 插入来自sibling的key到parent */
        nd->keys[idx] = sibling->keys[sibling->n - 1];
        
        /* 移动"child"的兄弟节点的最后一个孩子到"child->children[0]" */
        if (!child->leaf) {
            child->children[0] = sibling->children[sibling->n];
        }
        
        child->n++;
        sibling->n--;
    }
    
    // 想nd->children[idx+1]借一个key，插入到nd->children[idx]中
    void borrow_from_next(struct node *nd, int idx)
    {
        assert(idx + 1 <= nd->n);
        struct node *child = nd->children[idx];
        struct node *sibling = nd->children[idx + 1];
        
        /* 插入来自parent的key */
        child->keys[child->n] = nd->keys[idx];
        child->n++;
        
        /* 移动 sibling->children[0] 到 child的最后一个children */
        if (!child->leaf) {
            child->children[child->n] = sibling->children[0];
        }
        
        /* 插入兄弟节点的第一个key到parent */
        nd->keys[idx] = sibling->keys[0];
        
        /* 在兄弟节点中删除第一个key */
        for (int i = 0; i < sibling->n - 1; i++) {
            sibling->keys[i] = sibling->keys[i + 1];
        }
        /* 移动兄弟节点的children指针 */
        if (!sibling->leaf) {
            for (int i = 0; i < sibling->n; i++) {
                sibling->children[i] = sibling->children[i + 1];
            }
        }
        sibling->n--;
    }
    
    // 合并nd->children[idx]和nd->children[idx+1], 合并后，free nd->children[idx+1]
    void merge(struct node *nd, int idx)
    {
        assert(idx + 1 <= nd->n);
        struct node *child = nd->children[idx];
        struct node *sibling = nd->children[idx + 1];
        
        /* 下移parent的key到child中 */
        child->keys[child->n] = nd->keys[idx];
        child->n++;
        
        /* 在parent中删除下移了的key */
        for (int i = idx; i < nd->n - 1; i++) {
            nd->keys[i] = nd->keys[i + 1];
        }
        /* 在parent中删除sibling指针 */
        for (int i = idx+1 ; i < nd->n; i++) {
            nd->children[i] = nd->children[i + 1];
        }
        nd->n--;
        
        /* 移动sibling中的所有key到"child"中 */
        int offset = child->n;
        for (int i = 0; i < sibling->n; i++) {
            child->keys[i + offset] = sibling->keys[i];
        }
        child->n += sibling->n;
        
        /* 释放sibling空间 */
        delete sibling;
    }


private:
    struct node *root;
    int t;
};


int main()
{
    b_tree t(3); // A B-Tree with minium degree 3
    
    t.insert(1);
    t.insert(3);
    t.insert(7);
    t.insert(10);
    t.insert(11);
    t.insert(13);
    t.insert(14);
    t.insert(15);
    t.insert(4);
    t.insert(5);
    t.insert(20);
    t.insert(22);
    t.insert(2);
    t.insert(17);
    t.insert(12);
    t.insert(6);
    
    cout << "Traversal of tree constructed is\n";
    t.traverse();
    cout << endl;
    
    t.remove(6);
    cout << "Traversal of tree after removing 6\n";
    t.traverse();
    cout << endl;
    
    t.remove(13);
    cout << "Traversal of tree after removing 13\n";
    t.traverse();
    cout << endl;
    
    t.remove(7);
    cout << "Traversal of tree after removing 7\n";
    t.traverse();
    cout << endl;
    
    t.remove(4);
    cout << "Traversal of tree after removing 4\n";
    t.traverse();
    cout << endl;
    
    t.remove(2);
    cout << "Traversal of tree after removing 2\n";
    t.traverse();
    cout << endl;
    
    t.remove(16);
    cout << "Traversal of tree after removing 16\n";
    t.traverse();
    cout << endl;
    return 0;
}

```

### 6. B+树

![image-20201014110229351](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014110229351.png)

![image-20201014110240127](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20201014110240127.png)

#### B和B+树的区别

Let’s see the difference between B-tree and B+ tree:

| S.NO |                            B TREE                            |                           B+ TREE                            |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  1.  |        All internal and leaf nodes have data pointers        |              Only leaf nodes have data pointers              |
|  2.  | Since all keys are not available at leaf, search often takes more time. | All keys are at leaf nodes, hence search is faster and accurate.. |
|  3.  |       No duplicate of keys is maintained in the tree.        | Duplicate of keys are maintained and all nodes are present at leaf. |
|  4.  | Insertion takes more time and it is not predictable sometimes. |   Insertion is easier and the results are always the same.   |
|  5.  | Deletion of internal node is very complex and tree has to undergo lot of transformations. | Deletion of any node is easy because all node are found at leaf. |
|  6.  |     Leaf nodes are not stored as structural linked list.     |       Leaf nodes are stored as structural linked list.       |
|  7.  |            No redundant search keys are present..            |            Redundant search keys may be present..            |

### 7. Trie树

#### 1. 定义

[Trie](http://en.wikipedia.org/wiki/Trie) is an efficient information re***Trie\***val data structure. Using Trie, search complexities can be brought to optimal limit (key length). If we store keys in binary search tree, a well balanced BST will need time proportional to **M \* log N**, where M is maximum string length and N is number of keys in tree. Using Trie, we can search the key in O(M) time. However the penalty is on Trie storage requirements

<img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Trie.png" alt="img" style="zoom:33%;" />

Every node of Trie consists of multiple branches. Each branch represents a possible character of keys. We need to mark the last node of every key as end of word node. A Trie node field *isEndOfWord* is used to distinguish the node as end of word node. A simple structure to represent nodes of the **English alphabet can be as following,**

```c++
    struct node{
        char c;
        struct node* children[ALPHABET_SIZE];
        bool is_end_of_word;
        int ref_num;        /* 当前node被多少node引用，孩子节点或 end of word node 会引用 */
        /* 还可以有一个数据域，但是不影响tire tree实现,所以未加入 */
    
        node(char c, bool isEndOfWord) : c(c), is_end_of_word(isEndOfWord),ref_num(0) {
            fill(begin(children),end(children),nullptr);
        }
    };
```

#### 2.插入

Inserting a key into Trie is a simple approach. Every character of the input key is inserted as an individual Trie node. Note that the *children* is an array of pointers (or references) to next level trie nodes. The key character acts as an index into the array *children*. If the input key is new or an extension of the existing key, we need to construct non-existing nodes of the key, and mark end of the word for the last node. If the input key is a prefix of the existing key in Trie, we simply mark the last node of the key as the end of a word. The key length determines Trie depth.

```c++
    void insert(const string &key){
        struct node *cur = root;
        for(int i = 0;i<key.size();i++){
            int idx = key[i] - 'a';
            if(cur->children[idx] == nullptr){
                cur->children[idx] = new node(key[i],false);
                cur->ref_num++;
            }
            cur = cur->children[idx];
        }
        cur->is_end_of_word = true;
        cur->ref_num++;
    }
```

#### 3. 搜索

Searching for a key is similar to insert operation, however, we only compare the characters and move down. The search can terminate due to the end of a string or lack of key in the trie. In the former case, if the *isEndofWord* field of the last node is true, then the key exists in the trie. In the second case, the search terminates without examining all the characters of the key, since the key is not present in the trie.

```c++
    // success return founded node, else nullptr
    struct node *search(const string &key){
        struct node *cur = root;
        for(int i = 0;i<key.size();i++){
            int idx = key[i] - 'a';
            cur = cur->children[idx];
            if(cur == nullptr){
                return nullptr;
            }
        }
        
        if(cur ->is_end_of_word) return cur;
        else return nullptr;
    }
```

#### 4. 插入和搜索的时间&空间复杂度

对于一个基26个字母的tire树，其复杂度如下。

Insert and search costs **O(key_length)**,  however the memory requirements of Trie is **O(ALPHABET_SIZE \* key_length \* N)** 。key length代表关键字的平均长度，N代表tire树中关键字的个数。

#### 5. 删除操作

During delete operation we delete the key in **bottom up** manner using recursion. The following are possible conditions when deleting key from trie,

1. Key may not be there in trie. Delete operation should not modify trie.
2. 对于每个节点，如果是独立节点（不是其他string的前缀），直接删除，并减少其父亲节点的引用计数。
3. 如果不是独立节点，减少自身引用计数。

```c++
  void remove(const string &key){
        if(search(key) == nullptr)  // 没有该key，无法删除
            return;
        int idx = key[0] - 'a';
        _remove(key,root,root->children[idx],0);   
    }


 /**
     * 递归删除node， i是key的偏移量
     * @param key 要删除的key
     * @param p nd的父亲节点
     * @param nd 指向tire树中字符=key[i]的节点
     * @param i key的偏移量
     */
    void _remove(const string &key,struct node *p, struct node *nd, int i){
        assert(nd != nullptr);
        
        if(i == key.size() - 1){    /* key的末尾 */
            if(nd->is_end_of_word && nd->ref_num == 1){    /* 独立节点：end of word节点且只有自身引用 */
                p->ref_num--;
                p->children[key[i]-'a'] = nullptr;
                delete nd;
            }else if(nd->is_end_of_word){       /* 非独立节点 & end of word节点，但是存在孩子节点引用 */
                nd->ref_num--;
            }
            nd->is_end_of_word = false;
            return;
        }
        
        int idx = key[i+1] - 'a';
        _remove(key,nd,nd->children[idx],i+1);
        if(nd->ref_num == 0){    /* 删除本节点，父亲节点少一个孩子 */
            p->ref_num--;
            p->children[key[i]-'a'] = nullptr;
            delete nd;
        }
    }
```

## 3. Hash表


### 1. 哈表表引入

以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的**关键码与向量单元的秩之间建立起映射关系**。理论分析和实验统计均表明，只要散列表、散列函数以及冲突排解策略设计得当，**散列技术可在期望的常数时间内实现词典的所有接口操作**。也就是说，**就平均时间复杂度的意义而言，可以使这些操作所需的运行时间与词典的规模基本无关。**尤为重要的是，**散列技术完全摒弃了“关键码有序”的先决条件，故就实现词典结构而言，散列所特有的通用性和灵活性是其它方式无法比拟的、*

#### 散列表的基本构思，可以概括为：

> 开辟物理地址连续的桶数组ht[]，借助散列函数hash()，将词条关键码key映射为桶地址hash(key)，从而快速地确定待操作词条的物理位置。

哈希表学习的关键：

1. 散列表
2. 散列函数
3. 冲突排解

### 2. 哈希表

#### 2.1 哈希表中的术语

- 桶（bucket）或桶单元：存放词条（或其引用）的单元。

- 散列函数，在词条与桶地址之间约定的某种映射关系：

  hash() : key -> hash(key),这里的hash()称作散列函数（hashfunction）。反过来，hash(key)也称作key的散列地址（hashingaddress），亦即与关键码key相对应的桶在散列表中的秩。

- 装填因子：

  词典中实际需要保存的词条 数N（比如25000门）远远少于可能出现的词条数R（10^8门），但R个词条中的任何一个都有可能出现在词典中。**将散列表中非空桶的数目与桶单元总数的比值称作装填因子（load factor）**。也即空间利用率。

### 3. 散列函数

不妨先假定关键码均为[0,R)范围内的整数。将词典中的词条数记作N，散列表长度记作M，于是通常有：

R>>M>N

如图9.6所示，散列函数hash()的作用可理解为，将关键码空间[0,R)压缩为散列地址空间[0,M)。

![image-20200330213943989](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330213943989.png)

#### 3.1 设计原则

1. **确定性**，无论所含的数据 项如何，词条E在散列表中的映射地址hash(E.key)必须完全取决于其关键码E.key。
2. **映射过程自身不能过于复杂**，唯此方能保证散列地址的计算可快速完成，从而保证查询或修改操作整体的O(1)期望执行时间
3. 所有关键码经映射后**应尽量覆盖整个地址空间[0,M**)，唯此方可充分利用有限的散列表空间。也就是说，函数hash()最好是满射。
4. 最为重要的一条原则就是，关键码映射到各桶的概率应尽量接近于1/M。**若关键码均匀且独立地随机分布**，这也是任意一对关键码相互冲突的概率。就整体而言，这等效于将关键码空间“均匀地”映射到散列地址空间，从而避免导致极端低效的情况

#### 3.2 除余法（division method）

符合上述要求的一种最简单的映射办法，就是将散列表长度M取作为素数，并将关键码key 映射至key关于M整除的余数：

hash(key) = key mod M

**采用除余法时必须将M选作素数。**

#### 3.3 MAD法（multiply-add-divide method）

除余法的缺点在于，相邻关键码所对应的散列地址，总是彼此相邻。如图a，M=17。取key为{ 2011, 2012, 2013, 2014, 2015, 2016 }。

![image-20200330215158944](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330215158944.png)

为弥补这一不足，可采用所谓的MAD法将关键码key映射为：
$$
(a \times key + b ) mod M，其中M仍为素数，a > 0，b > 0，且a\ mod\ M 不等 0
$$


#### 3.4（伪）随机数法

上述各具特点的散列函数，验证了我们此前的判断：越是随机、越是没有规律，就越是好的散列函数。按照这一标准，任何一个（伪）随机数发生器，本身即是一个好的散列函数。比如，可直接使用C/C++语言提供的rand()函数，将关键码key映射至桶地址：
$$
rand(key)\ mod\ M
$$
需特别留意的是，由于不同计算环境所提供的（伪）随机数发生器不尽相同，故在将某一系统中生成的散列表移植到另一系统时，必须格外小心。

### 4. 冲突解决 - 开散列

**开散列**：开散列法又叫链地址法(开链法)。 开散列法：首先对关键码集合用散列函数计算散列地址，具有相同地址的关键码归于同一子集合，每一个子集合称为一个桶，各个 桶中的元素通过一个单链表链接起来，各链表的头结点存储在哈希表中。

#### 4.1 多槽位（multiple slots）法

最直截了当的一种对策是，将彼此冲突的每一组词条组织为一个小规模的子词典，分别存放 于它们共同对应的桶单元中。比如一种简便的方法是，统一将各桶细分为更小的称作槽位（slot） 的若干单元，每一组槽位可组织为向量或列表。

![image-20200330220705521](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330220705521.png)

多槽位法的缺陷，显而易见。首先由图9.10可见，绝大多数的槽位通常都处于空闲状态。准确地讲，若每个桶被细分为k个槽位，则当散列表总共存有N个词条时，装填因子：
$$
\lambda' = N/(kM) = \lambda/k
$$
将降低至原先的1/k。

其次，很难在事先确定槽位应细分到何种程度，方可保证在任何情况下都够用。比如在极端 情况下，有可能所有（或接近所有）的词条都冲突于单个桶单元。此时，尽管几乎其余所有的桶 都处于空闲状态，该桶却会因冲突过多而溢出。

#### 4.2 独立链（separate chaining）法

![image-20200330220847698](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330220847698.png)

相对于多槽位法，独立链法可更为灵活地动态调整各子词典的容量和规模，从而有效地降低空间消耗。但在查找过程中一旦发生冲突，则**需要遍历整个列表，导致查找成本的增加。**

#### 4.3 公共溢出区法

公共溢出区（overflowarea）法的思路如图9.12所示，在原散列表（图(a)）之外另设一个词典结构Doverflow（图(b)），一旦在插入词条时发生冲突就将该词条转存至Doverflow中。就效果而言，Doverflow相当于一个存放冲突词条的公共缓冲池，该方法也因此得名。

![image-20200330221005232](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330221005232.png)

这一策略构思简单、易于实现，在冲突不甚频繁的场合不失为一种好的选择。同时，既然公共溢出区本身也是一个词典结构，不妨直接套用现有的任何一种实现方式因此就整体结构而言，此时的散列表也可理解为是一种递归形式的散列表。

### 5. 冲突解决-闭散列

**闭散列**：也叫开放地址法，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把key存放到表中 “下一个” 空位中去

#### 5.1 线性试探（linear probing）法

开放定址策略最基本的一种形式是：在插 入关键码key时，若发现桶单元ht[hash(key)]已被占用，则 转而试探桶单元ht[hash(key) + 1]；若ht[hash(key) + 1] 也被占用，则继续试探ht[hash(key) + 2]；...；如此不断， 直到发现一个可用空桶。当然，为确保桶地址的合法，最后还 需统一对M取模。因此准确地，第i次试探的桶单元应为：
$$
ht[ (hash(key) + i)\ mod\ M ]， i = 1, 2, 3, ...
$$

##### 5.1.1 查找链

采用开放地址策略时，散列表中每一组相互冲突的词条都将被视作一个有序序列，对其中任 何一员的查找都需借助这一序列。对应的查找过程，可能终止于三种情况： 

（1）在当前桶单元命中目标关键码，则成功返回；

 （2）当前桶单元非空，但其中关键码与目标关键码不等，则须转入下一桶单元继续试探； 

（3）当前桶单元为空，则查找以失败返回。

##### 5.1.2 局部性

由上可见，线性试探法中组成各查找链的词条，**在物理上保持一定的连贯性，具有良好的数据局部性，故系统缓存的作用可以充分发挥**，查找过程中几乎无需I/O操作。尽管闭散列策略同时也会在一定程度上增加冲突发生的可能，但只要散列表的规模不是很小，装填因子不是很大，则相对于I/O负担的降低而言，这些问题都将微不足道。也正因为此，相对于独立链等开散列策略，闭散列策略的实际应用更为广泛。

##### 5.1.3 懒惰删除

查找链中任何一环的缺失，都会导致后续词条因无法抵达而丢失，表现为有时无法找到实际已存在的词条。因此若采用开放定址策略，则在执行删除操作时，需同时做特别的调整。

如图9.15(a)所示，按常规方法简单地将其清空，则该桶的缺失将导致对应的查找链“断裂”，从而致使五个后继词条“丢失”尽管它们在词典中的确存在，但查找却会失败。

![image-20200330222737289](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330222737289.png)

**修复方法：将要删除的bucket元素标识为脏，并不真正删除**

![image-20200330222752489](https://cdn.jsdelivr.net/gh/ravenxrz/PicBed/img/image-20200330222752489.png)

请注意，**设有懒惰删除标志位的桶，应与普通的空桶一样参与插入操作**。比如在图9.15(b)基础上，若拟再插入关键码2096，则应从ht[hash(2096)]=ht[5]出发，沿查找链经5次试探抵达桶ht[9]，并如图(c)所示将关键码2096置入其中。需特别说明的是，此后不必清除该桶的懒惰删除标志尽管按照软件工程的规范，最好如此。

#### 5.2 装填因子

就对散列表性能及效率的影响而言，装填因子 $\lambda=N/M$ 是最为重要的一个因素。只要能将装填因子控制在适当范围以内，闭散列策略的平均效率，通常都可保持在较为理想的水平。比如，一般的建议是保持<0.5。这一原则也适用于其它的定址策略，比如对独立链法而言，建议的装填因子上限为0.9。当前主流的编程语言大多提供了散列表接口，其内部装填因子的阈值亦多采用与此接近的阈值。

#### 5.3 重散列（rehashing）

其实，将装填因子控制在一定范围以内的方法并不复杂，重散列即是常用的一种方法。重散列的效果，只不过是将原词条集，整体“搬迁”至容量至少加倍的新散列表中。与可扩充向量同理，这一策略也可使重散列所耗费的时间，在分摊至各次操作后可以忽略不计。

### 6. 一个简单hashtable实现

```c++
/**
 * Created by a2855 on 2020/10/5.
 * hash函数， key mod 13
 * hash碰撞处理， 开放定址法--线性探测
 */
#include <iostream>
#include <vector>
#include <cassert>
using namespace std;

template <typename K, typename V>
class hash_table{
private:
    // 哈希表中的一项
    struct item{
        K key;
        V value;
    
        item(){}

        item(K key, V value) : key(key), value(std::move(value)) {}
    };
    
public:
    
    hash_table(): counter(0){
        table.resize(5,nullptr);
    }
    
    ~hash_table(){
        for(const auto & ptr: table){
            delete ptr;
        }
    }
    
    void put(K key, V value){
        int idx = -1;
        
        if(search(key,idx)){
            table[idx]->value = value;
        }else{
            item *kv = new item(key,value);
            table[idx] = kv;
            counter++;
        }
    }
    
    bool get(K key, V& value){
        int idx = -1;
        
        if(search(key,idx)){
            value = table[idx]->value;
            return true;
        }else{
            cerr<< "no such key in table\n";
            return false;
        }
    }
    
private:
    
    int hash(K key){
        return key % 13;        //TODO: 这里其实限制了key为可取余的类型，所以不算通用类型了
    }
    
    /* search 指定key，如果当前table中有key，return true, 并返回该key所在的idx
     * 如果当前table中没有该key，return false, 并返回一个空slot的idx
     */
    bool search(K key,int &idx){
        const int cur_len = table.size();
        int i = hash(key);
        const int flag = (i-1) % cur_len;

        /* 是否需要rehash */
        if((float)counter / table.size() >= load_factor){
             rehash();
        }

        /* 执行search */
        for (; i != flag;i = (i+1) % cur_len){
            if(table[i] == nullptr){
                idx = i;
                return false;
            }else if(table[i]->key == key){
                idx = i;
                return true;
            }
        }
        
        idx = -1;
        return false;
    }
    
    /* rehash */
    void rehash(){
        cout << "rehash"<<endl;
        assert((float)counter / table.size() >= load_factor);
        table.resize(table.size()<<1);
    }
    
private:
    static const float load_factor;
    int counter;  // 有效item个数
    vector<item*> table;    // table
};

// 静态变量初始化
template <typename K, typename V>
const float ::hash_table<K,V>::load_factor = 0.7f;



int main()
{
    hash_table<int,string> table;
    table.put(1,"zhang");
    table.put(2,"zhang");
    table.put(3,"zhang");
    table.put(4,"zhang");
    table.put(5,"xing");
    table.put(6,"xing");
    table.put(7,"xing");
    table.put(8,"rui");
    table.put(9,"rui");
    
    string value;
    for(int i = 1;i<=9;i++){
        table.get(i,value);
        cout << value << endl;
    }
    
    return 0;
}
```